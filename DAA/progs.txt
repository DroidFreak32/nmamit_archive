==> p01_selsor.c <==
#include <stdio.h>
#include <stdlib.h>
#include<sys/time.h>
//void selection();
int n,j,i,temp=0,a[50],min;
struct timeval tim;
double dtime1,dtime2;
int main()
{
    printf("enter the  number of elements\n");
    scanf("%d",&n);
    for(i=0;i<n;i++)
        a[i]=rand()%100;
    printf("entered elements\n");
    for(i=0;i<n;i++)
        printf(" %d\t",a[i]);
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    selection();
    gettimeofday(&tim,NULL);
    dtime2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("\nSorted Array: \n");
    for(i=0;i<n;i++)
    {
        printf(" %d\t",a[i]);
    }

    printf("\n Elapsed time is %lf\n", dtime2-dtime1);
    printf("\n\n%lf\n\n",tim.tv_usec);
    return 0;
}
void selection()
{
  for(i=0;i<n-1;i++){
    min = i;
    for(j=i+1;j<n;j++)
        if(a[min]>a[j])
        {
            min = j;
            temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
}

==> p02_bbl.c <==
#include <stdio.h>
#include <stdlib.h>
#include<sys/time.h>
void bsort(int a[100],int n);
struct timeval tim;
double dtime1,dtime2;
int main(){
    int a[100],n,i,v;
    printf("Enter the values of n:");
    scanf("%d",&n);
    for(v=0; v<n; v++)
        a[v]=rand()%100;
        printf("\nElements entered: ");
    for(i=0;i<n;i++)
        printf("%d ",a[i]);
    bsort(a,n);
    printf("\nElements after sorting\n");
    for(i=0;i<n;i++)
        printf("%d\t",a[i]);
    printf("\nElapsed time is %lf\n", dtime2-dtime1);
    return 0;
}
void bsort(int a[100],int n){
    int i,temp,j;
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    for(i=0;i<n;i++)
        for(j=0;j<n-1;j++)
            if(a[j]>a[j+1]){
                temp=a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
            }
    gettimeofday(&tim,NULL);
    dtime2=tim.tv_sec+(tim.tv_usec/1000000.0);

}

==> p03_brute.c <==
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
//void selection();
int patmatch();
int j,i,ind,n,m;
char t[50],p[50];
struct timeval tim;
double dtime1,dtime2;
int main()
{
    printf("Enter the String: ");

    scanf("%s",t);
    printf("\nEntered String: %s",t);
    n=strlen(t);


    printf("\nEnter the Pattern to search: ");
    scanf("%s",p);
    printf("\nEntered Pattern: %s",p);
    m=strlen(p);
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    ind=patmatch();
    gettimeofday(&tim,NULL);
    dtime2=tim.tv_sec+(tim.tv_usec/1000000.0);
    if(ind==-1)
        printf("\nPattern NOT found");
    else
        printf("\nPattern found at position %d\n",ind);
    printf("\n Elapsed time is %lf\n", dtime2-dtime1);
    return 0;
}
int patmatch(){
    for(i=0;i<=n-m;i++){
        j=0;
        while(j<m && p[j]==t[i+j])
            j++;
        if(j==m)
            return i;
    }
    return -1;
}

==> p05_quick.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
    int partition(int a[], int l, int r) {
        int p, i, j, temp;
        p = a[l];
        i = l;
        j = r + 1;
        do {
            do {
                i = i + 1;
            } while (a[i] < p && i <= r);
            do {
                j = j - 1;
            } while (a[j] > p);
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        } while (i < j);
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
        temp = a[l];
        a[l] = a[j];
        a[j] = temp;
        return j;
    }
void quick(int a[], int l, int r) {
    int s;
    if (l < r) {
        s = partition(a, l, r);
        quick(a, l, s - 1);
        quick(a, s + 1, r);
    }
}
int main() {
    int i, n, a[1000];
    struct timeval tim;
    double dtim1, dtim2;
    printf("Enter the number of Elements\n");
    scanf("%d", & n);
    for (i = 0; i < n; i++)
        a[i] = rand() % 50;
    printf("Array Elements are\n");
    for (i = 0; i < n; i++)
        printf("%d\t", a[i]);
    gettimeofday( & tim, NULL);
    dtim1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    quick(a, 0, n - 1);
    gettimeofday( & tim, NULL);
    dtim2 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    printf("\nThe Sorted array is\n");
    for (i = 0; i < n; i++) {
        printf("%d\t", a[i]);
    }
    printf("\nElapsed time is %lf seconds\n", dtim2 - dtim1);
    return 0;
}
==> p06_isort.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
int i,n,j,temp,a[20];
int main(){
    struct timeval tim;
    double dtime1,dtime2;
    printf("Enter the no of elements: ");
    scanf("%d",&n);
    for(i=0;i<n;i++)
        a[i]=rand()%100;
    printf("\nArray elements: ");
    for(i=0;i<n;i++)
      printf("%d ",a[i]);
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    insertion();
    gettimeofday(&tim,NULL);
    dtime2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("\nArray after sorting: ");
    for(i=0;i<n;i++)
      printf("%d ",a[i]);
    printf("\nElapsed time: %f seconds",dtime2-dtime1);
}
void insertion(){
for(i=1;i<n;i++){
    temp=a[i];
    j=i-1;
    while(temp<a[j]&&(j>=0)){
        a[j+1]=a[j];
        j=j-1;
    }
    a[j+1]=temp;
}
}

==> p07_dfs_traversal.c <==
#include <stdio.h>
#include <stdlib.h>
#include<sys/time.h>
int a[50][50];
int visited[50];
int e,v1,v2,i,j,k;
int v,r;
struct timeval tim;
double dtime1,dtime2;
void dfs(int k){
    int w,count=0;
    count=count+1;
    visited[k]=count;
    static int h=1;
    printf("\n v %d is :",h);
    h++;
    printf("%d",k);
    for(w=1;w<=r;w++){
        if(a[k][w]==1 && visited[w]==0)
            dfs(w);
    }
}
int main(){
    printf("Enter number of vertices:");
    scanf("%d",&r);
    printf("Enter number of edges:");
    scanf("%d",&e);
//    for(i=0;i<r;i++)
//        for(j=0;j<r;j++)
//            a[i][j]=0;
    for(i=0;i<e;i++){
        printf("Enter vertex %d and vertex%d:",i+1,i+2);
        scanf("%d%d",&v1,&v2);
        a[v1][v2]=a[v2][v1]=1;
    }
    printf("Adjacency matrix:\n");
    for(i=1;i<=r;i++){
        for(j=1;j<=r;j++)
            printf("%d\t",a[i][j]);
        printf("\n");
    }
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    for(i=0;i<50;i++)
        visited[i]=0;
    for(k=1;k<=r;k++)
        if(visited[k]==0)
            dfs(k);
    gettimeofday(&tim,NULL);
    dtime2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("\nElapsed time is %f:",dtime2-dtime1);
    return 0;
}

==> p08_dfs_reachability.c <==
#include <stdio.h>
    int A[20][20], visited[20], count = 0, n;
void dfs(int v) {
    int w;
    count = count + 1;
    visited[v] = count;
    printf("%d  \n", v);
    for (w = 1; w <= n; w++) {
        if (A[v][w] && visited[w] == 0) {
            dfs(w);
        }
    }
}
int main() {
    int i, j, v1, v2, s, e;
    printf("Enter the number of vertices of the graph:\n");
    scanf("%d", & n);
    printf("Enter the number of edges of the graph:\n");
    scanf("%d", & e);
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            A[i][j] = 0;
        }
    }
    printf("Enter the edges of the graph one by one:\n");
    for (i = 1; i <= e; i++) {
        scanf("%d %d", & v1, & v2);
        A[v1][v2] = A[v2][v1] = 1; //undirected graph
        //A[v1][v2]=1//directed graph
    }
    for (i = 1; i <= n; i++) {
        visited[i] = 0;
    }
    printf("Enter the vertex:\n");
    scanf("%d", & s);
    printf("Adjacency matrix:\n");
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++)
            printf("%d\t",A[i][j]);
        printf("\n");
    }
    printf("The vertices reachable from %d are:\n", s);
    dfs(s);
    // getch();
    return 0;
}
==> p09_bfs_traversal.c <==
#include <stdio.h>
    int q[50], front = 1, rear = 0, n, count = 0, i, j, A[20][20], visited[20];
void bfs(int v) {
    int q[50], front = 1, rear = 0, w;
    count = count + 1;
    visited[v] = count;
    printf("%d is visited\n", v);
    q[++rear] = v; //insert v to queue
    while (front <= rear) {
        v = q[front];
        for (w = 1; w <= n; w++) {
            if (visited[w] == 0 && A[v][w] == 1) {
                count++;
                visited[w] = count;
                printf("%d is visited\n", w);
                q[++rear] = w;
            }
        }
        front++;
    }
}
int main() {
    int v1, v2, e, k;
    printf("Enter the number of vertices of the graph\n");
    scanf("%d", & n);
    printf("Enter the number of edges of the graph:\n");
    scanf("%d", & e);
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            A[i][j] = 0;
        }
    }
    printf("Enter the edges of the graph one by one:\n");
    for (i = 1; i <= e; i++) {
        scanf("%d %d", & v1, & v2);
        A[v1][v2] = A[v2][v1] = 1; //undirected graph
        //A[v1][v2]=1//directed graph
    }
    for (i = 1; i <= n; i++) {
        visited[i] = 0;
    }
    for (k = 1; k <= n; k++) {
        if (visited[k] == 0)
            bfs(k);
    }
    return 0;
}
==> p10_heapsort.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
void heapy(int a[],int n)
{
    int i,k,v,heap,j;
    for(i=(n/2);i>=1;i--)
    {
        k=i;
        v=a[k];
        heap=0;
        while(!heap&&2*k<=n)
        {
            j=2*k;
            if(j<n)
            {
                if(a[j]<a[j+1])
                    j++;
            }
            if(v>=a[j])
                heap=1;
            else
            {
                a[k]=a[j];
                k=j;
            }
        }
        a[k]=v;
    }
}
void maximumkey(int a[],int n)
{
    int temp;
    temp=a[1];
    a[1]=a[n];
    a[n]=temp;
    n=n-1;
    heapy(a,n);
    if(n>=1)
        maximumkey(a,n);
}
int main()
{
    struct timeval tim;
    double d1,d2;
    int a[100],n,i;
    printf("Enter size: ");
    scanf("%d",&n);
    printf("\nEnter the numbers: ");
    for(i=1;i<=n;i++)
        a[i]=rand()%50;
    printf("\nThe numbers are:\n");
    for(i=1;i<=n;i++)
        printf("%d\t",a[i]);
    gettimeofday(&tim,NULL);
    d1=tim.tv_sec+(tim.tv_usec/1000000.0);
    heapy(a,n);
     printf("\nThe heap tree is:\n");
    for(i=1;i<=n;i++)
        printf("%d\t",a[i]);
    maximumkey(a,n);
    gettimeofday(&tim,NULL);
    d2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("\nThe sorted array:\n");
    for(i=1;i<=n;i++)
        printf("%d\t",a[i]);
    printf("\nExecution Time: %lf",d2-d1);
    return 0;
}

==> p11_weak_conected.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
int a[10][10],visited[10],e,n,count=0;
void dfs(int v)
{
    int w;
    count=count+1;
    visited[v]=count;
    printf("%d is visited\n",v);
    for(w=1;w<=n;w++)
    {
        if(a[v][w]==1 && visited[w]==0)
            dfs(w);
    }
}

int main()

{
    struct timeval tim;
    double d1,d2;
    int i,k,j,v1,v2,s,con=0,flag=0;
    printf("Enter the number of vertices\n");
    scanf("%d",&n);
    printf("Enter the number of edges\n");
    scanf("%d",&e);
    for(i=0;i<=n;i++)
    for(j=0;j<=n;j++)
    a[i][j]=0;
    for(i=1;i<=n;i++)
    visited[i]=0;
    printf("Enter the edges\n");
    for(i=1;i<=e;i++)
    {
        scanf("%d%d",&v1,&v2);
        a[v1][v2]=1;

    }
    printf("Adjacency matrix:\n");
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++)
            printf("%d\t",a[i][j]);
        printf("\n");
    }
    gettimeofday(&tim,NULL);
    d1=tim.tv_sec+(tim.tv_usec/1000000.0);
    for( k=1;k<=n;k++)
    {
        flag=0;
        for(i=1;i<=n;i++)
            visited[i]=0;
        dfs(k);
        for(i=1;i<=n;i++)
        {
            if(visited[i]==0)
            {
                flag=1;
                break;
            }
        }
        if(flag==0)
        {
            con=con+1;
        }
    }
    gettimeofday(&tim,NULL);
    d2=tim.tv_sec+(tim.tv_usec/1000000.0);
    if(con==n)
    printf("Strongly connected\n");
    else
    if(con==0)
    printf("Not connected\n");
    else
    printf("Weakly connected\n");
    printf("\nExecution Time: %lf",d2-d1);
}

==> p12_warshall_algo.c <==
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include<sys/time.h>
struct timeval tim;
double t1,t2;
int a[100][100],r[100][100],n;

void warshall()
{
    int i,j,k;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            r[i][j]=a[i][j];
        }
    }
    for(k=1;k<=n;k++)
    {
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
               r[i][j]=r[i][j]||(r[i][k]&&r[k][j]);
            }
        }
    }
    printf("The transitive closure is \n");
     for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            printf("%d ",r[i][j]);
        }
        printf("\n");
    }

}


int main()
{

    //double t1,t2;
    int i,j;
    printf("Enter the order \n");
    scanf("%d",&n);
    printf("Enter the adjacency matrix \n");
     for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    gettimeofday(&tim,NULL);
    t1=tim.tv_sec+(tim.tv_usec/1000000.0);
    warshall();
    gettimeofday(&tim,NULL);
    t2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("Elapsed time is %lf s",t2-t1);
    return 0;
}

==> p13_floyd.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <math.h>

int w[100][100],d[100][100],n;

void floyd()
{
    int i,j,k;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            d[i][j]=w[i][j];
        }
    }
    for(k=1;k<=n;k++)
    {
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                d[i][j]=fmin(d[i][j],d[i][k]+d[k][j]);
            }
        }
    }
    printf("Distance matrix of the shortest paths length \n");
     for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            printf("%d \t",d[i][j]);
        }
        printf("\n");
    }

}

int main()
{
    struct timeval tim;
    double t1,t2;
    int i,j;
    printf("Enter the size of weight matrix of the graph\n");
    scanf("%d",&n);
    //n=4;
    printf("Enter the weight matrix of a graph \n");
     for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            scanf("%d",&w[i][j]);
        }
    }
    gettimeofday(&tim,NULL);
    t1=tim.tv_sec+(tim.tv_usec/1000000.0);
    floyd();
    gettimeofday(&tim,NULL);
    t2=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("Elapsed time is %lf s",t2-t1);
    return 0;
}

==> p14_topo_sort.c <==
#include <stdio.h>
#include <stdlib.h>
#include<sys/time.h>
int A[20][20],visited[20],count=0,n,order[10],k=0;
void dfs(int v)
{
    int w;
    count=count+1;
    visited[v]=count;
    for(w=1;w<=n;w++)
    {
        if(A[v][w] && visited[w]==0)
        {
            dfs(w);                     //8055//

        }
    }
    order[k]=v;
    k++;
}
int main()
{
	struct timeval tim;
    double d1,d2;
    int i,j,k,v1,v2,e;
    printf("Enter no of vertices : ");
    scanf("%d",&n);
    printf("Enter no of edges:");
    scanf("%d",&e);
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            A[i][j]=0;
        }
    }
    printf("Enter the edges of the graph one by one:\n");
    for(i=1;i<=e;i++)
    {
        scanf("%d %d",&v1,&v2);
        A[v1][v2]=1;

    }
	gettimeofday(&tim,NULL);
    d1=tim.tv_sec+(tim.tv_usec/1000000.0);
    for(i=1;i<=n;i++)
    {
        visited[i]=0;

    }
    for(k=1;k<=n;k++)
    {
        if(visited[k]==0)
        dfs(k);

    }
	gettimeofday(&tim,NULL);
    d1=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("The topological ordering is:\n");
    for(i=n-1;i>=0;i--)
    {
        printf("%d\t",order[i]);
    }
    printf("\nAdjacency matrix:\n");
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++)
            printf("%d\t",A[i][j]);
        printf("\n");
    }
    printf("\nEkecution Time: %lf",d2-d1);
    return 0;
}


==> p15_topo_source.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
struct timeval tim;
double dtime1, dtime2;
int order[10], A[10][10], n, indegree[10], visited[10], e, k = 0;
int is_all_nodes_visited() {
    int i;
    for (i = 1; i <= n; i++) {
        if (visited[i] == 0)
            return 0;
    }
    return 1;
}
int main() {
    int i, j, v1, v2, w;;
    printf("Enter no of vertices of the graph\n");
    scanf("%d", & n);
    printf("Enter the number of edges of the graph:\n");
    scanf("%d", & e);
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            A[i][j] = 0;
        }
    }
    for (i = 1; i <= n; i++) {
        indegree[i] = 0;
    }
    for (i = 1; i <= n; i++) {
        visited[i] = 0;
    }
    printf("Enter the edges of the graph one by one:\n");
    for (i = 1; i <= e; i++) {
        scanf("%d %d", & v1, & v2);
        A[v1][v2] = 1;
    }
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            if (A[i][j] == 1)
                indegree[j] = indegree[j] + 1;
        }
    }
    gettimeofday( & tim, NULL);
    dtime1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    while (1) {
        if (is_all_nodes_visited())
            break;
        else
            for (i = 1; i <= n; i++) {
                if (indegree[i] == 0 && visited[i] == 0) {
                    order[k] = i;
                    k++;
                    visited[i] = 1;
                    for (w = 1; w <= n; w++) {
                        if (A[i][w] == 1 && visited[w] == 0) {
                            indegree[w]--;
                        }
                    }
                }
            }
    }
    printf("The Topological ordering is:\n");
    for (i = 0; i < n; i++) {
        printf("%d\t", order[i]);
    }
    gettimeofday( & tim, NULL);
    dtime2 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    printf("\n Elapsed time is %lf second\n", dtime2 - dtime1);
    return 0;
}
==> p16_binomial.c <==
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
struct timeval tim;
double dtime1, dtime2;
int c[10][10];
void bin(int n, int k) {
    int m, i, j;
    for (i = 0; i <= n; i++) {
        m = (i < k ? i : k);
        for (j = 0; j <= m; j++) {
            if (j == 0 || j == i)
                c[i][j] = 1;
            else
                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
        }
    }
}
int main() {
    int m, n, i, j, k;
    printf("\n enter the value of n and k \n");
    scanf("%d%d", & n, & k);
    gettimeofday( & tim, NULL);
    dtime1 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    bin(n, k);
    for (i = 0; i <= n; i++) {
        m = (i < k ? i : k);
        for (j = 0; j <= m; j++) {
            printf("%d\t", c[i][j]);
        }
        printf("\n");
    }
    printf("\n Value of %dC%d=%d \n", n, k, c[n][k]);
    gettimeofday( & tim, NULL);
    dtime2 = tim.tv_sec + (tim.tv_usec / 1000000.0);
    printf("\n Elapsed time is %lf second\n", dtime2 - dtime1);
    return 0;
}
==> p17_n_queens.c <==
/* N - Queens problem using Backtracking */
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
int place(int k, int a[]) {
    int i;
    for (i = 1; i < k; i++) {
        if ((a[k] == a[i]) || (abs(i - k) == abs(a[i] - a[k])))
            return 0;
    }
    return 1;
}
void nqueen(int n) {
    int k = 1;
    // queen 1 in row 1
    int i, count = 0; // count indicates the no of solutions
    int a[10];
    // a[k] holds column no of k th queen
    a[k] = 0;
    //queen 1,in row 1 ,column 0
    while (k != 0) {
        a[k] = a[k] + 1;
        //backtrack till k=1
        //queen k,in next column
        while ((a[k] <= n) && (place(k, a) == 0)) {
            a[k] = a[k] + 1;
        }
        if (a[k] <= n) {
            if (k == n)
            //if we reached last row then print solution
            {
                count++;
                printf("Solution No %d:\n", count);
                for (i = 1; i <= n; i++) {
                    printf("Queen No: %d is placed in Row No: %d and Column No %d\n",i, i, a[i]);
                }
            } else {
                k++;
                a[k] = 0;
            }
        } else {
            k--;
            //backtrack to previous row
        }
    }
}
int main() {
    int n, noofsoln;
    printf("Enter the number of queens\n");
    scanf("%d", & n);
    if (n <= 3 && n > 1)
        printf("no solutions\n");
    else
        nqueen(n);
}
==> p18_kruskal.c <==
/* Kruskal's algorithm to find minimum spanning tree */
#include<stdio.h>
int A[10][10], B[10][10]; //A-given graph; B - Minimum Spanning Tree
int n, e;
int root[10];
void update(int v1, int v2) {
    int i, t;
    t = root[v2];
    for (i = 1; i <= n; i++) {
        if (root[i] == t)
            root[i] = root[v1];
    }
}
void FindMin(int * v1, int * v2) {
    int edge = 0, i, j;
    for (i = 1; i <= n; i++)
        for (j = i + 1; j <= n; j++) {
            if ((edge > A[i][j] || edge == 0) && A[i][j] > 0) {
                edge = A[i][j]; * v1 = i; * v2 = j;
            }
        }
}
int Kruskals() {
    int i, j, ecounter = 0;
    int v1, v2;
    int cost;
    int total_cost = 0;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) {
            if (i == j)
                B[i][j] = 0;
            else
                B[i][j] = 999;
        }
        //initialization of adjacency matrix
    while (ecounter < (n - 1)) {
        FindMin( & v1, & v2);
        cost = A[v1][v2];
        A[v1][v2] = A[v2][v1] = 0;
        if (root[v1] != root[v2]) {
            B[v1][v2] = B[v2][v1] = cost;
            update(v1, v2);
            total_cost = total_cost + cost;
            ecounter++;
        }
    }
    return total_cost;
}
int main() {
    int v1, v2;
    int i, j, cost;
    //clrscr();
    printf("Enter no of vertices\n");
    scanf("%d", & n);
    printf("Enter no of edges\n");
    scanf("%d", & e);
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) {
            if (i == j)
                A[i][j] = 0;
            else
                A[i][j] = 999;
        }
        //initialization of adjacency matrix
    printf("Enter the Edges one by one\n");
    for (i = 1; i <= e; i++) {
        printf("Edge %d: ", i);
        scanf("%d%d", & v1, & v2);
        printf("Weight: ");
        scanf("%d", & cost);
        A[v1][v2] = A[v2][v1] = cost;
    }
    for (i = 1; i <= n; i++) {
        root[i] = i;
    }
    printf("The given graph is:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++)
            printf("%d\t", A[i][j]);
        printf("\n");
    }
    cost = Kruskals();
    printf("The minimum spanning tree for the given graph is:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++)
            printf("%d\t", B[i][j]);
        printf("\n");
    }
    printf("\nThe total cost is: %d", cost);
}
==> p19_prims.c <==
/*Prim's algorithm to find minimum spanning tree*/
#include <stdio.h>
int A[10][10], B[10][10]; //A-given graph; B - Minimum Spanning Tree
int n, e;
int visited[10];
void FindMin(int * v1, int * v2) {
    int edge = 0, i, j;
    for (i = 1; i <= n; i++)
        for (j = i + 1; j <= n; j++) {
            if ((visited[i] == 1 && visited[j] != 1) || (visited[i] != 1 && visited[j] == 1)) {
                if ((edge > A[i][j] || edge == 0) && A[i][j] > 0) {
                    edge = A[i][j]; * v1 = i; * v2 = j;
                }
            }
        }
}
int Prims() {
    int i, j;
    int v1, v2;
    int cost;
    int total_cost = 0;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) {
            if (i == j)
                B[i][j] = 0;
            else
                B[i][j] = 999;
        }
        //initialization of adjacency matrix
    for (i = 1; i < n; i++) {
        FindMin( & v1, & v2);
        cost = A[v1][v2];
        B[v1][v2] = B[v2][v1] = cost;
        visited[v1] = visited[v2] = 1;
        total_cost = total_cost + cost;
    }
    return total_cost;
}
int main() {
    int v1, v2;
    int i, j, cost;
    //clrscr();
    printf("Enter no of vertices\n");
    scanf("%d", & n);
    printf("Enter no of edges\n");
    scanf("%d", & e);
    for (i = 1; i <= n; i++)
        for (j = 1; j <= n; j++) {
            if (i == j)
                A[i][j] = 0;
            else
                A[i][j] = 999;
        }
        //initialization of adjacency matrixprintf("Enter the Edges one by one\n");
    for (i = 1; i <= e; i++) {
        printf("Edge %d: ", i);
        scanf("%d%d", & v1, & v2);
        printf("Weight: ");
        scanf("%d", & cost);
        A[v1][v2] = A[v2][v1] = cost;
    }
    for (i = 1; i <= n; i++) {
        visited[i] = 0;
    }
    visited[1] = 1;
    cost = Prims();
    printf("The given graph is:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++)
            printf("%d\t", A[i][j]);
        printf("\n");
    }
    printf("The The minimum spanning tree for the given graph is:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++)
            printf("%d\t", B[i][j]);
        printf("\n");
    }
    printf("\nThe total cost is: %d", cost);
}
==> p20_memoryknap.c <==
/*Knapsack problem using memory functions - dynamic programming*/
#include<stdio.h>
#include<stdlib.h>
int Values[15], Weights[15];
int W, n;
int V[15][15];
int max(int i, int k) {
    if (i > k) return i;
    else return k;
}
int MFKnapsack(int i, int j) {
    int value;
    if (V[i][j] < 0) {
        if (j < Weights[i])
            value = MFKnapsack(i - 1, j);
        else
            value = max(MFKnapsack(i - 1, j), Values[i] + MFKnapsack(i - 1, j - Weights[i]));
        V[i][j] = value;
    }
    return V[i][j];
}
int main() {
    int i, j, val;
    //clrscr();
    printf("Enter no of items\n");
    scanf("%d", & n);
    printf("Enter the capacity of knapsack\n");
    scanf("%d", & W);
    printf("Enter the weight and value of each item\n");
    for (i = 1; i <= n; i++) {
        printf("\nItem No: %d ->", i);
        printf("Weight: ");
        scanf("%d", & Weights[i]);
        printf("Value: ");
        scanf("%d", & Values[i]);
    }
    for (i = 0; i <= n; i++)
        for (j = 0; j <= W; j++) {
            if (i == 0 || j == 0) {
                V[i][j] = 0;
            } else {
                V[i][j] = -1;
            }
        }
    val = MFKnapsack(n, W);
    printf("The optimal value is %d\n", val);
    printf("The items added are:\n");
    for (i = n, j = W; i > 0; i--) {
        if (V[i][j] != V[i - 1][j]) {
            printf("%d\t", i);
            j = j - Weights[i];
        }
    }
	return 0;
}
==> p21_dynamicknap.c <==
/*Knapsack problem using dynamic programming*/
#include<stdio.h>
#include<stdlib.h>
int Values[15], Weights[15];
int W, n;
int V[15][15];
int max(int i, int k) {
    if (i > k) return i;
    else return k;
}
int Knapsack() {
    int i, j;
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= W; j++) {
            if (j - Weights[i] < 0) {
                V[i][j] = V[i - 1][j];
            } else {
                V[i][j] = max(V[i - 1][j], Values[i] + V[i - 1][j - Weights[i]]);
            }
        }
    }
    return V[n][W];
}
int main() {
    int i, j, val;
    // clrscr();
    printf("Enter no of items\n");
    scanf("%d", & n);
    printf("Enter the capacity of knapsack\n");
    scanf("%d", & W);
    printf("Enter the weight and value of each item\n");
    for (i = 1; i <= n; i++) {
        printf("\nItem No: %d ->", i);
        printf("Weight: ");
        scanf("%d", & Weights[i]);
        printf("Value: ");
        scanf("%d", & Values[i]);
    }
    for (i = 0; i <= n; i++)
        V[i][0] = 0; //initialize first rowfor(j=0;j<=W;j++)
    V[0][j] = 0; //initialize first column
    val = Knapsack();
    printf("The Knapsack table %d\n");
    for (i = 0; i <= n; i++) {
        for (j = 0; j <= W; j++) {
            printf("%d\t", V[i][j]);
        }
        printf("\n");
    }
    printf("The optimal value is \n", val);
    printf("The items added are:\n");
    for (i = n, j = W; i > 0; i--) {
        if (V[i][j] != V[i - 1][j]) {
            printf("%d\t", i);
            j = j - Weights[i];
        }
    }
    return 0;
}
==> p22_horsepool.c <==
#include <stdio.h>
#include <string.h>
char p[50], t[50];
int table[256];
int m, n;
void shifttable() {
    int i, j, temp;
    for (i = 0; i < 256; i++) {
        table[i] = m;
    }
    for (j = 0; j < m - 1; j++) {
        temp = p[j];
        table[temp] = m - 1 - j;
    }
}
int horspool() {
    int i, k;
    int temp;
    shifttable();
    i = m - 1;
    while (i <= n - 1) {
        k = 0;
        while ((k <= m) && (p[m - 1 - k] == t[i - k]))
            k++;
        if (k == m)
            return (i - m + 1);
        else
            temp = t[i];
        i += table[temp];
    }
    return -1;
}
int main() {
    int r;
    printf("Enter the text\n");
    scanf("%s", t);
    n = strlen(t);
    printf("Enter the pattern\n");
    scanf("%s", p);
    m = strlen(p);
    r = horspool();
    if (r == -1)
        printf("Pattern not found\n");
    else
        printf("Pattern found at position %d\n", r);
}
==> p23_compsort.c <==
#include <stdio.h>
#include <stdlib.h>
#include <cmath>
#include <sys/time.h>

int a[20],n,count[20],s[20];

void comparison_sort()
{
    int i,j;
    for(i=0;i<n;i++)
        count[i]=0;
    for(i=0;i<n-1;i++)
        for(j=i+1;j<n;j++)
        {
            if(a[i]<a[j])
                count[j]++;
            else
                count[i]++;
        }
    for(i=0;i<n;i++)
        s[count[i]]=a[i];
}

int main()
{
    int i;
    struct timeval tim;
    double dtime1,dtime2;
    printf("\nEnter the number of elements:");
    scanf("%d",&n);
    for(i=0;i<n;i++)
        a[i]=rand()%100;
    printf("\nThe Array:\n");
    for(i=0;i<n;i++)
        printf("%d\t",a[i]);
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    comparison_sort();
    gettimeofday(&tim,NULL);
    dtime1=tim.tv_sec+(tim.tv_usec/1000000.0);
    printf("\nThe Sorted Array:\n");
    for(i=0;i<n;i++)
        printf("%d\t",s[i]);
     printf("\nElapsed time:%f seconds",dtime2-dtime1);
}
